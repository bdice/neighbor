// Copyright (c) 2018, Michael P. Howard.
// This file is released under the Modified BSD License.

// Maintainer: mphoward

#ifndef NEIGHBOR_LBVH_ROPE_TRAVERSER_H_
#define NEIGHBOR_LBVH_ROPE_TRAVERSER_H_

#include "LBVHTraverser.h"

#include "hoomd/GlobalArray.h"
#include "hoomd/GPUFlags.h"
#include "hoomd/Autotuner.h"

namespace neighbor
{

//! Linear bounding volume hierarchy traverser using stackless rope scheme.
/*!
 * The LBVH is traversed using a stackless scheme based on skip ropes. The
 * general idea is to store (for each node) the left child (to descend if an
 * overlap occurs) and a skip "rope" to the next node that should be processed
 * (if there is no overlap). The skip rope may point to the LBVHSentinel, which
 * indicates that traversal should be terminated.
 *
 * In order to efficiently perform this traversal, the LBVH data is heavily compressed
 * by the traverser. Each node is represented by an int4 (16B). This is much smaller than
 * the original LBVH data (~56B), and is achieved by compressing the bounding boxes into
 * a low-precision (10-bit) form. The LBVH root node is discretized into 2^10 bins. The
 * remaining bounding boxes are snapped onto this grid in a way that ensures correctness
 * (lower bounds are always rounded down, while upper bounds are always rounded up). The
 * (x,y,z) components are concatenated into one integer (4B) versus the original float3 (12B).
 * The nodes are decompressed into floats during traversal, again in a conservative way to
 * ensure the original node is always enclosed by the compressed/decompressed node. Some
 * additional overlaps can be generated by intersecting these nodes, but this is usually
 * a small number for typical simulations.
 *
 * The query spheres are permitted to take on Scalar precision. During traversal, the sphere
 * is translated (in Scalar precision) by the desired image. The sphere is then dropped into
 * single precision for traversal, but the sphere radius is rounded up to ensure that the
 * original volume is still enclosed. This again guarantees that overlaps that would be found
 * in Scalar precision are always found in the lower precision representation. There may be
 * some false positive overlaps, but these could be filtered or removed in a narrow-phase
 * collision if desired.
 */
class LBVHRopeTraverser : public LBVHTraverser
    {
    public:
        //! Constructor
        LBVHRopeTraverser(std::shared_ptr<const ExecutionConfiguration> exec_conf);

        //! Destructor
        ~LBVHRopeTraverser();

        //! Traverse the LBVH.
        virtual void traverse(const GlobalArray<unsigned int>& out,
                              const GlobalArray<Scalar4>& spheres,
                              unsigned int N,
                              const LBVH& lbvh,
                              const GlobalArray<Scalar3>& images = GlobalArray<Scalar3>());

        //! Access the compressed LBVH data for traversal
        const GlobalArray<int4>& getData() const
            {
            return m_data;
            }

        //! Set the kernel autotuner parameters
        /*!
         * \param enable If true, run the autotuners. If false, disable them.
         * \param period Number of traversals between running the autotuners.
         */
        void setAutotunerParams(bool enable, unsigned int period)
            {
            m_tune_traverse->setEnabled(enable);
            m_tune_traverse->setPeriod(period);

            m_tune_compress->setEnabled(enable);
            m_tune_compress->setPeriod(period);
            }

    private:
        GlobalArray<int4> m_data;        //!< Internal representation of the LBVH for traversal
        GPUFlags<float3> m_lbvh_lo;   //!< Lower bound of tree
        GPUFlags<float3> m_lbvh_hi;   //!< Upper bound of tree
        GPUFlags<float3> m_bins;      //!< Bin size for compression

        std::unique_ptr<Autotuner> m_tune_traverse; //!< Autotuner for traversal kernel
        std::unique_ptr<Autotuner> m_tune_compress; //!< Autotuner for compression kernel

        //! Compresses the lbvh into internal representation
        void compress(const LBVH& lbvh);
    };

} // end namespace neighbor

#endif // NEIGHBOR_LBVH_ROPE_TRAVERSER_H_
